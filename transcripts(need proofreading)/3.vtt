WEBVTT

00:00:04.080 --> 00:00:07.930
<v Chris Lattner>Hello and welcome to the swift community podcast. I'm your host, Chris Lattner.

00:00:08.500 --> 00:00:15.300
<v Chris Lattner>Today we're talking about how the swift languages improved. Today. I'm joined by two co-hosts who have run proposals through the swift evolution process.

00:00:16.140 --> 00:00:26.110
<v Chris Lattner>First, I'd like introduce Kelvin Ma. He's an Apple platform engineer at Detroit Labs in Detroit, Michigan, and is an Alamofire developer and on the board of directors for the Alamofire Foundation. Hi, John.

00:00:26.640 --> 00:00:28.875
<v Kelvin Ma>Hi, Chris. Thanks for having me.

00:00:29.125 --> 00:00:34.850
Yeah, I'm excited to get to talk with you. Can you give us a little bit of info on your background and where you're coming from?

00:00:34.910 --> 00:00:48.400
<v Jon Shier>Sure. By day, I'm Apple Platform's developer for Detroit Labs in Detroit, Michigan. We're a services company building apps for companies who need great apps doing cross platform and web work.

00:00:49.190 --> 00:00:50.250
<v Jon Shier>By night, I'm

00:00:50.800 --> 00:01:00.450
<v Jon Shier>one of the two developers of the Alamofire Networking Library and I'm also serving on the board of directors for the non-profit foundation that helps protect our work.

00:01:01.570 --> 00:01:12.150
<v Chris Lattner>That's fantastic. And among other things, you have successfully gotten a result type into the swift language with se-0235. So we'll talk about that a little bit more later.

00:01:12.940 --> 00:01:17.070
<v Chris Lattner>The third coast we have today is none other than Taylor Swift.

00:01:17.640 --> 00:01:21.370
<v Chris Lattner>At least on the apple developer forum, Taylor Swift is actually Kelvin Ma.

00:01:21.950 --> 00:01:32.750
<v Chris Lattner>Kelvin is a student at the University of Illinois, Urbana Champaign. He already has one swift evolution proposal accepted as working on a new one to get character literals into the swift language.

00:01:33.340 --> 00:01:35.750
<v Chris Lattner>Kevin, can you tell us a little bit more about your background?

00:01:36.000 --> 00:01:47.280
<v Kelvin Ma>Hey, Chris. Thanks for having me. Yeah, I'm a junior in computer engineering at UIUC we are known for a corn, and I'm also the maintainer of the PNG,

00:01:48.160 --> 00:01:53.230
<v Kelvin Ma>a image decoder library and the swift.noise procedural noise generation library.

00:01:53.560 --> 00:02:01.680
<v Chris Lattner>That's awesome. I spent a few years at University of Illinois and, in addition to a lot of corn, it's also very cold in winter.

00:02:02.693 --> 00:02:07.913
<v Kelvin Ma>Oh, yeah, we just had the polar vortex, which, luckily we all see alived.

00:02:08.353 --> 00:02:12.083
<v Chris Lattner>Yeah, well, hopefully you guys all thought out and it gets better soon.

00:02:13.233 --> 00:02:23.503
<v Chris Lattner>So before we go on, I want to have you briefly touch on your se-0184 proposal. Can you give us a rundown of what that was? I just want to make you read the title of this.

00:02:23.903 --> 00:02:29.103
<v Kelvin Ma>That was basically taking all of the various

00:02:29.873 --> 00:02:39.543
<v Kelvin Ma>manual memory management methods on the the unsafe pointer types and trying to avoid some consistency and like completeness on them.

00:02:40.633 --> 00:02:50.943
<v Kelvin Ma>One of the things that we did was to get the deallocate to be uniform on all of the types, including the unmutable pointer types,

00:02:51.493 --> 00:02:54.443
<v Kelvin Ma>and we also tried to get deinitializes

00:02:55.093 --> 00:02:58.333
<v Kelvin Ma>set to "repeating", "to" and,

00:02:59.633 --> 00:03:04.263
<v Kelvin Ma>the move-initializes. I think were another goal on that end.

00:03:05.193 --> 00:03:09.383
<v Kelvin Ma>We didn't touch the buffer pointers as much as, like we could have mainly,

00:03:10.233 --> 00:03:19.183
<v Kelvin Ma>we limited that to the deallocate and allocation methods, and we were going to save like all the memory state stuff later.

00:03:19.193 --> 00:03:30.693
<v Chris Lattner>So this all went to Swift 4.1. And this is the kind of thing where a lot of time and energy goes into making more usage consistent uniform, which leads to it being better for everyone.

00:03:30.703 --> 00:03:36.250
<v Kelvin Ma>Yeah, it was like actually, it was really like a bunch of changes like packaged into one proposal.

00:03:36.500 --> 00:03:50.053
<v Jon Shier>All right, so, Chris, it's been over 200 evolution proposals. Has this process been what you envisaged way back when Swift became open source? Or how has it changed and evolved over the years?

00:03:50.163 --> 00:03:55.193
<v Chris Lattner>Yeah. Swift evolution's a really interesting kind of social process in its community process.

00:03:55.933 --> 00:03:57.243
<v Chris Lattner>I guess

00:03:57.793 --> 00:04:13.824
<v Chris Lattner>When back in time when Swift was first getting off the ground, we had a very small team people working on it. And, we just have weekly design meetings and everybody got in this little tiny conference room and there's a big white board and we talk about things, and figure out week by week what we were doing.

00:04:14.514 --> 00:04:27.404
<v Chris Lattner>As the team ended up growing and this was before Swift launch. The room got too small, the team got too big, more and more people got involved. And so we ended up having to change how we structured meetings. And so some of the

00:04:27.914 --> 00:04:29.194
<v Chris Lattner>"old timers"

00:04:30.074 --> 00:04:37.624
<v Chris Lattner>they had been working on it from beginning became the core design team. And, when Swift went open source,

00:04:38.214 --> 00:04:49.924
<v Chris Lattner>there's a big question of how open should the language be right? Is this going to be a push a tar ball of code out there kind of open source release process? Do we allow patches come in?

00:04:50.614 --> 00:04:56.054
<v Chris Lattner>What about the design of the language itself? And so I'm really happy that we decided to go with a

00:04:57.034 --> 00:04:58.644
<v Chris Lattner>quite open model where

00:04:59.554 --> 00:05:13.244
<v Chris Lattner>the community is empowered to help make the language better. Not just language, the library, everything else that goes with Swift. And so swift evolution was kind of ah consequence of tha. The actual design of the evolution proposal,

00:05:14.384 --> 00:05:22.234
<v Chris Lattner>The Gregor, if I recall, was the one that took the lead on figuring out what the process was. He has a lot of experience from the C++ committee

00:05:23.464 --> 00:05:28.294
<v Chris Lattner>years ago. I think he was heavily inspired by the Rust community. There's

00:05:28.864 --> 00:05:39.774
<v Chris Lattner>Python and several other communities have proposal processes, and so, I'm not exactly sure how the process he went through. But I think that he drew on a lot of the ideas around other communities to try to pull together

00:05:40.314 --> 00:05:46.814
<v Chris Lattner>a process. And the process is really about trying to get people involved and engaged, but also,

00:05:47.684 --> 00:05:52.544
<v Chris Lattner>can standardize and uniformize the proposals themselves and make sure they're high quality and things like that.

00:05:53.474 --> 00:05:56.514
<v Chris Lattner>Kelvin, how did you get involved in Swift evolution initially?

00:05:56.624 --> 00:06:06.231
<v Kelvin Ma>I mean, my first proposal was se-184 and that was kind of just like me. Like being frustrated with the unsafe pointer APIs cause,

00:06:07.441 --> 00:06:13.471
<v Kelvin Ma>there's not a big user baseball with them, so they hadn't really been looked at a lot back at Swift 3.0.

00:06:14.261 --> 00:06:27.731
<v Kelvin Ma>And like, Harlan Haskins and Joe Groff, like, really helped, like, kind of teach me how to make, like, a formal proposal, cause I'd never ?? anything up and, like, push that to the process.

00:06:28.481 --> 00:06:34.931
<v Kelvin Ma>And like, especially back then it was, like mostly on email. So it was even more in the wilderness than it is now.

00:06:35.521 --> 00:06:37.771
<v Kelvin Ma>Well, I'm glad. Like I had guidance on that.

00:06:38.221 --> 00:06:40.971
<v Chris Lattner>Yeah, that's a great thing about getting

00:06:41.771 --> 00:06:45.131
<v Chris Lattner>the support from other people who care about various aspects of the project.

00:06:45.581 --> 00:06:55.661
<v Kelvin Ma>Yeah, and Andrew Trick was, like, definitely like interested in. Cause I think the memory management part of Swift is like his domains.

00:06:56.311 --> 00:07:08.631
<v Chris Lattner>It's great they can reach out to the experts who helped build the thing that needs to be improved in certain cases. That's great. And how about you, Jon? How did you first get involved in Swift evolution. What was your first contact with it?

00:07:09.211 --> 00:07:28.401
<v Jon Shier>Well, I was always very interested when you announced Swift that was going to be open source eventually. And I was looking forward to seeing exactly what form that would take. Because before then, Apple's Swift open source involvement had been limited to basically the tar ball dumps that you had

00:07:29.151 --> 00:07:37.131
<v Jon Shier>talked about. Aside from a few very limited scenarios. So it was very interesting to see what would come out of this. So when they announced,

00:07:37.921 --> 00:08:02.531
<v Jon Shier>feel like, development's going to be in the open and you're going to be able to propose changes to the language and vote on them over time as well. Then that became a very interesting part because as an Objective-C developer for maybe 10 years before then. It was very frustrating to see a lot of the language changes come and go, and really having the only feedback that you could offer be an apple bug reports and things like that.

00:08:03.048 --> 00:08:29.038
<v Jon Shier>It was really the only way that I'd ever been able to talk to anyone about, you know, certain things about the Objective-C language. So I was very interested in following Swift evolution once it started up and proposals started coming through and starting to see, both, you know, more public information about the direction of the language and how Apple and the community wanted to shape it.

00:08:29.628 --> 00:08:34.878
<v Jon Shier>The purpose was what the points people wanted to touch on. So it's always been very interesting that way.

00:08:35.238 --> 00:08:37.548
<v Chris Lattner>It's a really interesting and challenging

00:08:39.278 --> 00:08:43.238
<v Chris Lattner>project, in a sense. Because on one hand Apple has the culture of

00:08:44.078 --> 00:08:45.618
<v Chris Lattner>wanting to surprise and delight

00:08:46.128 --> 00:09:00.268
<v Chris Lattner>the developers. And so good news, everybody. This year we have literals for Objective-C, and people are very excited about this. And it's a great, that's a great point of confluence for the developer community. WWDC typically,

00:09:00.828 --> 00:09:16.138
<v Chris Lattner>But on the other hand, that leads to some tension, because Apple has a lot of internal developers, a lot of internal rigor, but it doesn't have the whole ecosystem of developers out there, and you can get sometimes better inside and better feedback when you get more people involved.

00:09:17.438 --> 00:09:35.638
<v Chris Lattner>But there's also another issue, which is one of the challenges of Swift evolution is, kind of setting out that road map of saying, over the next year we want work on this. And several times in the past, the goal posts have been moved as reality dawns, we can't get as much done as we wanted to or things like that. And so there's a,

00:09:36.398 --> 00:09:44.108
<v Chris Lattner>It's a challenging expectations setting exercise where you say, we're gonna do ABI stability this year. No, we mean next year.

00:09:44.738 --> 00:09:47.388
<v Chris Lattner>You know, things like that. So it's an interesting challenge.

00:09:47.788 --> 00:09:49.968
<v Jon Shier>Right now is the language changes. It's been,

00:09:50.608 --> 00:10:19.213
<v Jon Shier>It's been very good to be able to look back and see the reasoning that the core team and the people who proposed various evolution proposals had for why they wanted different changes and things like that. And to look back and see that most of changes, you know, all had good reasons and very specific things. But occasionally it's tough to say, especially from the apple side, that these proposals came in because of some larger overarching plan that Apple just wasn't willing to talk about. So,

00:10:19.813 --> 00:10:27.083
<v Jon Shier>it's been a good way to document the history of everything, both from proposals from Apple and the community.

00:10:27.583 --> 00:10:45.973
<v Chris Lattner>Yeah, well, and one of the good things about the Swift evolution proposals is that you end up with a written document that describes what changes. But then also the trade-offs and other things involved. And, this is a fairly high bar for many contributors, which

00:10:46.523 --> 00:10:52.983
<v Chris Lattner>I'd love to get your take on. But, the good result of this is you kind of really encourage,

00:10:53.573 --> 00:10:58.893
<v Chris Lattner>strong sense of discussion of ownership of really carefully considering trade-offs.

00:10:59.113 --> 00:11:06.633
<v Jon Shier>Yeah the evolution process has evolved itself from people just being able to do proposals, to now the latest

00:11:07.973 --> 00:11:26.633
<v Jon Shier>proposal plus implementation. I think we've seen because there are still proposals that are accepted but not fully implemented, which is an unfortunate sort of, you know, bit of documentation that exists of things that people are surprised, you know, don't match up. So I guess, as it's evolved, it's been

00:11:27.193 --> 00:11:30.583
<v Jon Shier>it's been good to see that, but it's also raised the bar even further.

00:11:31.473 --> 00:11:55.013
<v Kelvin Ma>Yeah, I think there was also some discussion about teach ability as being another requirement for some proposals. Cause as we've seen, like, Swift is moving pretty quickly and a lot of materials online tutorials like way out of date. So you keep getting people coming out to the forums, like asking about stuff that's not really relevant anymore. Not like the current way of doing things.

00:11:55.773 --> 00:12:03.703
<v Chris Lattner>Kelvin, can you give us a brief overview of how Swift evolution works? And if you have an idea, how do you go about getting it into swift?

00:12:04.180 --> 00:12:14.400
<v Kelvin Ma>Well, basically, you have, like an idea and when I've noticed is first like a while. Like it'll be on other discussions and you're kind of like,

00:12:15.180 --> 00:12:18.330
<v Kelvin Ma>you'll hear people start like touch on that maybe,

00:12:18.980 --> 00:12:28.690
<v Kelvin Ma>conceive of that idea and then maybe a short time while later it'll get its own topic. And then that would be like a ??, like people will talk about that

00:12:29.230 --> 00:12:32.490
<v Kelvin Ma>for a while and then slowly, like, crystallized into a proposal.

00:12:33.070 --> 00:12:39.290
<v Kelvin Ma>And then there's this like weird time, where it's like in a proposal but not merged into the evolution

00:12:39.860 --> 00:12:50.380
<v Kelvin Ma>repository were goes into like actual review. And if like once it goes into a view, that's like the end stage of it. Whether it was gonna pass or it's not. And then it's by then

00:12:51.380 --> 00:12:55.320
<v Kelvin Ma>with like, the implementation policy usually goes and pretty quickly. So

00:12:55.880 --> 00:13:05.790
<v Kelvin Ma>the the important part is like the pitch to proposal part where everything gets, like, hammered out and the draft gets polished and agreed upon.

00:13:05.860 --> 00:13:11.270
<v Chris Lattner>And tell me why is it complicated to get hundreds of people who have never met each other to agree on something?

00:13:12.280 --> 00:13:17.670
<v Kelvin Ma>I mean, you can't just answered your own question there. You got, like, a lot of different interest groups.

00:13:17.970 --> 00:13:19.660
<v Chris Lattner>Yeah, what could be easier right?

00:13:19.970 --> 00:13:34.000
<v Kelvin Ma>There's like a large group of iOS developers who, like, make up the majority of the user base and then, a very like a smaller but very vocal group like Linux developers like myself can advocate for other platforms that Swift supports.

00:13:34.730 --> 00:13:40.390
<v Kelvin Ma>And then there's just in general, like when you get a bunch of developers in the room, you're gonna have people with different philosophies.

00:13:40.980 --> 00:13:55.580
<v Kelvin Ma>And also just like different backgrounds and expertise, like the character literal proposal you had like a lot of people who knew a lot about Unicode, and a lot of people didn't know as much about Unicode. And like both groups people had like different opinions about

00:13:56.300 --> 00:13:57.730
<v Kelvin Ma>how it should proceed. And then,

00:13:58.280 --> 00:14:04.040
<v Kelvin Ma>you know, we had, like, some interesting insights about other non Unicode non ASCII codings.

00:14:04.660 --> 00:14:08.120
<v Kelvin Ma>Where it was probably beneficial to have that contribution in

00:14:08.870 --> 00:14:15.030
<v Kelvin Ma>and maybe less than official to have it like circulate around that Unicode centric discussion.

00:14:15.440 --> 00:14:27.150
<v Chris Lattner>Jon, you mentioned that Swift evolution proposals now requiring implantation. So can you share what used to happen? Why that was problematic and what changed and what you think about that?

00:14:27.270 --> 00:14:34.310
<v Jon Shier>Right. So there have been several proposals early on in Swift history that have been accepted

00:14:35.090 --> 00:14:55.080
<v Jon Shier>but not implemented. One of the ones that I can think of right now and I don't remember the number is the proposal that would re factor and refine the syntax around enum declarations and adding some additional capabilities to enums, including things like, I believe default associated value parameters and things like that.

00:14:55.600 --> 00:15:21.010
<v Jon Shier>Where the proposal's been accepted. You can look it up and it says yes, this should be part of the language, but it's not actually been implemented. And so I think that came around as part of a, well we need to have these things go together. It's not really tenable to have a proposal in some sort of limbo state where it's been accepted but not implemented. So it's not really officially part of the language. But we're just waiting for somebody to pick it up. Because,

00:15:21.600 --> 00:15:29.010
<v Jon Shier>yeah, it may include parts that require some really deep language and C++ expertise to build out the compiler. And so,

00:15:29.700 --> 00:15:54.410
<v Jon Shier>from my view, it was added in order to take care of that situation. And it did have the side effect of further increasing the bar of participation in the evolution process, where it's, you can still talk about and maybe pitch some proposals. But when it comes time to actually create an official one that will be voted on and things like that, an implementation needs to be provided with it.

00:15:55.700 --> 00:16:01.410
<v Chris Lattner>And another aspect of that is that having an implantation encourages

00:16:02.080 --> 00:16:14.390
<v Chris Lattner>the ideas to be really baked out. One of the challenges that we've had is that sometimes people have really good ideas, and then you go to implement them and you get a little bit of usage experience with them, and that experience sometimes

00:16:14.920 --> 00:16:16.830
<v Chris Lattner>uncovers problems and,

00:16:17.680 --> 00:16:23.360
<v Chris Lattner>by forcing an implantation. As you say. The downside is that you

00:16:23.950 --> 00:16:33.970
<v Chris Lattner>raised the bar. But you're also kind of providing another way to evaluate it. You know, people can get a snapshot of the compiler that has the feature enabled.

00:16:34.640 --> 00:16:39.030
<v Chris Lattner>We know that it can be implemented versus being a really great idea that,

00:16:39.620 --> 00:16:42.030
<v Chris Lattner>no human is smart enough to do.

00:16:42.670 --> 00:16:43.030
<v Chris Lattner>All right.

00:16:43.590 --> 00:17:00.030
<v Chris Lattner>Another aspect of it is that very early on it was, the community was saying, hey, we'd really like to see this. And Apple had effectively all the Swift engineers. And so it became an interesting way or an interesting situation where the community was

00:17:01.120 --> 00:17:04.330
<v Chris Lattner>sort of telling Apple how to spend its engineering time. And

00:17:05.310 --> 00:17:07.390
<v Chris Lattner>that was also a little bit strange sometimes.

00:17:07.690 --> 00:17:23.830
<v Jon Shier>Well, it's the community I think enjoyed that part of it because it was the first time it would really ever happened. So it was fun to be able to provide at least a little bit of a priority list and say, yes, we got we got apple to implement something that we really want rather than trying to surprise us with something.

00:17:24.720 --> 00:17:29.830
<v Chris Lattner>Yeah, yeah, well, and I think it's really good for Swift that people have a good sense of what's

00:17:30.420 --> 00:17:31.600
<v Chris Lattner>coming and what's happening.

00:17:32.120 --> 00:17:38.790
<v Chris Lattner>So 5 isn't out yet, but I think the content of it is pretty well understood. And that's really interesting.

00:17:39.320 --> 00:17:42.150
<v Chris Lattner>And not typically how Apple works at these things.

00:17:42.820 --> 00:17:52.470
<v Chris Lattner>So do you want to jump into the result proposal itself? Jon, maybe you can tell us a little about what result is and some of the background on where stuff came from, and why result is important.

00:17:52.730 --> 00:18:31.250
<v Jon Shier>Sure. So I think, you know, to see where a result came from, we could look at where Swift started, and that was with Swift 1 and no real error handling, where really the only way to represent errors was to either create your own custom type that had no real language support, or to bridge over NSError from Objective-C, which was no fun either. You know, the community adopted fairly quickly, various result types, or eithers or things like that. Basically types that allow you to represent a success and a failure from an operation. And so a lot of other languages already had similar types.

00:18:32.310 --> 00:18:41.120
<v Jon Shier>It's not a new idea, but it was something that was really necessary in version 1 of the language. And so it's really the type in Swift got its genesis there.

00:18:41.130 --> 00:19:08.700
<v Chris Lattner>And from my perspective, Swift 1 was really interesting because we planned to add error handling. We just didn't have time to put it into Swift 1. And so we knew it was coming. And Swift 1 was very similar to Objective-C in this area. In the way Objective-C used to work is used to have these auto released NSError ** parameters everywhere. And so error handling was very manual and quite error prone.

00:19:09.540 --> 00:19:23.050
<v Chris Lattner>I guess that's a terrible pun, but, and so Swift 1 was basically as good as Objective-C was. But moving forward, we wanted to introduce the throws capability and that propagation support.

00:19:23.250 --> 00:19:29.740
<v Jon Shier>Yeah, And so the Swift 2 with the automatic error handling and the sort of error manifesto

00:19:30.280 --> 00:20:09.790
<v Jon Shier>that's still available online as well. It was very interesting to see the evolution of into automatic error handling where, like you said, to move away from the very manual handling that was in Objective-C, we're not only, you had to manage these NSError pointer values and pass them through correctly, but unless certain APIs guaranteed it, you couldn't just check the error. You had to, like, check a separate return value as well to see if something succeeded or failed and then grab the errpr. So it was a very C level process for a language that you know, didn't usually have go that low level. So Swift 2 added,

00:20:11.060 --> 00:20:37.120
<v Jon Shier>you know, the automatic try catch and the initial, I think it was error protocol was the initial representation in Swift 2 to sort of abstract over both NSError and people's own error types and to integrate it with, actually with the language. And so this changed a lot of the use cases for result. But because try throws couldn't handle the synchronous case, there was still a big use case for a result.

00:20:37.450 --> 00:20:46.740
<v Chris Lattner>And so when work on Swift 2 was happening, we had this hope that, well yes we see all these result types out there, but that's okay, though. I'll go away when

00:20:47.420 --> 00:20:53.480
<v Chris Lattner>error handling, first class error handling support comes in. But let's just say that was not the case.

00:20:54.750 --> 00:21:04.470
<v Jon Shier>No. And it was one of those things where once that proliferation was there, it wasn't going to go away easily, especially without the synchronous case there. And so,

00:21:05.740 --> 00:21:17.870
<v Jon Shier>in my work on Alamofire, we sort of saw this firsthand where I think it was Alamofire 3 introduced, or 2 actually introduced a result type as part of the asynchronous handling of network requests.

00:21:18.860 --> 00:21:21.690
<v Jon Shier>And that was in the sort of Swift 1 and 2

00:21:22.350 --> 00:21:24.760
<v Jon Shier>timeline. So,

00:21:25.360 --> 00:22:03.500
<v Jon Shier>we've had a result type in Alamofire now for four years or so, and we were vending our own result type. So every so often we would get requests from, we would get issues from people in the community saying, "Why don't you use this result type instead, because it's the one that I use, and I would like not to have this conflict." Because, especially at the time and even still to this day, it was a little bit difficult for Swift to disambiguate between types of the same name in a lot of ways. So it was difficult for people sometimes to use the library when they already had their own result type. And we got requests for that quite a few times over the years.

00:22:04.100 --> 00:22:12.970
<v Jon Shier>Because it was a source of friction people. And I saw that also outside of Alamofire, where projects would naturally evolve their own result type because of

00:22:13.590 --> 00:22:18.690
<v Jon Shier>some error handling scenario they needed to handle that couldn't be done with the automatic

00:22:19.570 --> 00:22:21.450
<v Jon Shier>propagation of try catch.

00:22:21.500 --> 00:22:25.790
<v Chris Lattner>Right. And so you just brought the result

00:22:26.410 --> 00:22:29.750
<v Chris Lattner>proposal to the community. Everybody said yes, it was smooth selling, right?

00:22:30.000 --> 00:22:35.720
<v Jon Shier>You know, for something that's so popular, you would think that would happen. But it was,

00:22:36.280 --> 00:22:42.890
<v Jon Shier>you know, it was one of those things that for something such a simple data type, it raised such

00:22:43.670 --> 00:22:45.680
<v Jon Shier>rancor in the community in some ways.

00:22:46.000 --> 00:22:49.078
<v Chris Lattner>So result is literally an enum two cases.

00:22:49.100 --> 00:23:01.490
<v Jon Shier>Yes, I mean, and the spelling of those two cases is one of the things that we had to talk about. But yes, it's a two cases which in the abstract, represents success and failure. Whether they're named success or failure was a

00:23:02.040 --> 00:23:04.490
<v Jon Shier>was a topic of much debate. So

00:23:05.370 --> 00:23:21.310
<v Jon Shier>yeah, so what I initially tried to do was, I was like, we need this result type in here. Alamofire has a result type. Let me just propose that we use this result type as the official Swift result type, and then it'll be done, everyone can use it. We can all move on with our lives.

00:23:21.880 --> 00:23:27.790
<v Jon Shier>And so I did that in November of 2017. And the discussion that its bond in that initial proposal that I wrote

00:23:28.330 --> 00:23:34.090
<v Jon Shier>spend months and hundreds of comments with no real solution.

00:23:34.750 --> 00:23:38.260
<v Jon Shier>Multiple sides were chosen and

00:23:39.480 --> 00:23:41.270
<v Jon Shier>it was not quite the

00:23:41.970 --> 00:23:46.970
<v Jon Shier>the reception that I had anticipated for something so simple.

00:23:48.000 --> 00:23:52.113
<v Chris Lattner>Kelvin, did you see any any of this discussion going on? Were you involved at all?

00:23:52.125 --> 00:24:03.560
<v Kelvin Ma>I saw it. I chose not to involve myself in that. Cause I feel like there were enough people arguing about names that I didn't feel like I have anything to add.

00:24:03.630 --> 00:24:11.080
<v Chris Lattner>Is there anything that you saw coming out of the discussion that was interesting or at any positions that were fascinating?

00:24:11.950 --> 00:24:17.830
<v Kelvin Ma>Yeah I do, look too closely at it like I thought it was always a good idea, but at the same time like I had

00:24:18.360 --> 00:24:32.800
<v Kelvin Ma>gotten around it enough, like in my own libraries, I maintain, like I just tried to design the APIs where like, result won't be necessary. I feel like this definitely is a thing that, like you reach one enough that it should be in the standard library.

00:24:33.050 --> 00:24:49.060
<v Chris Lattner>Yeah, from my perspective, it was. And you know this is something people have been talking about for a really, really, really long time. And one of the reasons Jon, as through that you stepped up to drive this and it wasn't just me. Lots of people were happy obviously, is that

00:24:50.140 --> 00:24:52.120
<v Chris Lattner>Swift evolution is kind of,

00:24:54.050 --> 00:25:14.490
<v Chris Lattner>it's kind of like the legal process and in a way. Where you have ideas, but until they actually get tested in court or in the Swift evolution process, you don't know if an idea is good or bad. And even for me, I don't know what we'll end up happening with some of these proposals that get run. And how will the community react. And,

00:25:16.090 --> 00:25:27.260
<v Chris Lattner>for example, with result, many people said, oh, it's just completely trivial, it's a simple enum we don't need it. Or when async await happen, then we won't need it. It would be bad to put it in there because once it's in, it's in there forever.

00:25:27.850 --> 00:25:32.750
<v Chris Lattner>There are discussions about, well, should it be a result type or an ether type.

00:25:33.000 --> 00:25:38.330
<v Jon Shier>Yes. So the spelling in the shape of the type all had a lot of

00:25:38.950 --> 00:25:59.060
<v Jon Shier>different bits of discussion there. So my initial proposal and discussion from November of 2017 sort of petered out and then came back briefly in March of 2018. With this sort of idea, I believe, I forget who exactly, but one of the core team members was, you know said something about, well we could make it unconstrained because one of the big debates in my original proposal was that,

00:25:59.880 --> 00:26:19.510
<v Jon Shier>the result type in Alamofire is generic only to the success type, because the error type, especially since we're a networking library on top of URLSession, all of the errors that come out of URLSesson are just error. And so there's no way for us to have a generic error type in that situation.

00:26:20.260 --> 00:26:41.760
<v Jon Shier>That are on the error type side. So being able to have a result that could work with all of the, just plain errors that come out of all of Apple frameworks is pretty important to me. But eventually it was proposed that what if we just unconstrained both sides so that you know the success side could be anything, and the failure side could be anything, including any type of error in it.

00:26:42.320 --> 00:26:43.030
<v Jon Shier>And so,

00:26:43.620 --> 00:26:55.720
<v Jon Shier>you know, that was an interesting idea. But based off of my, you know, the amount of energy that I'd had to spend in that initial discussion, I sort of let it peter out until, 

00:26:56.900 --> 00:27:04.360
<v Jon Shier>until actually at try! Swift San Jose in the summer of 2018 the week of WW(DC), which I thought was a very,

00:27:05.420 --> 00:27:13.660
<v Jon Shier>a very unique opportunity to actually work alongside Apple engineers and other members who were deeply involved in the community all at once.

00:27:15.380 --> 00:27:29.800
<v Jon Shier>So it was a great event. However, when I went in there, my idea was, okay I'll implement result till we can see what it looks like, so then maybe I'll have another chance to show it to the community, and they can take another look at it and I'll have an implementation behind it.

00:27:30.320 --> 00:27:33.810
<v Jon Shier>Unfortunately, though, that day

00:27:34.350 --> 00:27:43.050
<v Jon Shier>Swift wasn't in a state where most of us could build it. So that sort of ?? my attempt to try and involve other members of the community in that implementation right away.

00:27:43.620 --> 00:27:55.130
<v Chris Lattner>Well and coming back to the design of the type itself, there's this fairly difficult trade-off decisions to make. So, as you said, one option is to say that,

00:27:55.720 --> 00:28:07.215
<v Chris Lattner>result only takes a value, the success value. One option is to say that it takes a success value and some other type that can be an arbitrary type so you could put like an int on the error case.

00:28:07.765 --> 00:28:27.025
<v Chris Lattner>And a lot of this comes into the discussion of what is the role of the type. Is it specifically to solve one asynchronous use case? Is it a way to solve broader interoperability with C code or other kinds of problems. Or is it really just a

00:28:27.645 --> 00:28:29.595
<v Chris Lattner>you know, an either type, which means

00:28:30.165 --> 00:28:49.800
<v Chris Lattner>it's just I have a thing A or thing B. And thing A would be the normal result and thing B would be the error result. And it's just a super generic type. And the fascinating and the difficult thing about these kinds of conversations is that you have people really smart, really good people coming at it from very different perspectives and with different motivations and goals.

00:28:50.000 --> 00:29:18.975
<v Jon Shier>Yeah, I think it was, I think, one of your ideas about the unconstrained type and saying that, well we could use them the result for scenarios where you can't produce an error, where maybe you need to be so performance that you could only produce ints or something like that for error codes. And so I was like, okay fine, this could be the low level error representation in Swift. We can have the automatic try catch at the high level that bundles everything up in an error, abstraction and things like that. And so,

00:29:20.275 --> 00:29:41.665
<v Jon Shier>eventually that's what I decided to try actually fully implement. So it was funny. I spoke at devworld in Melbourne, Australia, about Alamofire not about result. But while I was there, a guy came up to me and said, I think I recognize you from the internet. I was like, really from my work on Alamofire? He said no no, from those discussions about results on the Swift forums.

00:29:42.120 --> 00:29:48.845
<v Jon Shier>I was like, okay, so sort of, you know, my the result guy now, I guess?

00:29:48.855 --> 00:29:50.578
<v Kelvin Ma>Yep. The result guy.

00:29:50.750 --> 00:29:52.000
<v Chris Lattner>You get results.

00:29:52.135 --> 00:29:59.875
<v Jon Shier>Yeah. So at that point, I was like, okay, maybe I should go back to this and do another proposal in another implementation. So,

00:30:00.455 --> 00:30:08.690
<v Jon Shier>that was a whole interesting process itself. I mean, I adapted my existing proposal, open the type up, made it completely unconstrained.

00:30:09.470 --> 00:30:17.800
<v Jon Shier>Proposed, you know, did a pitch thread to propose it while also working to try implement it in the standard library.

00:30:17.960 --> 00:30:23.570
<v Chris Lattner>So people can click on the link in the show notes and go look at that. It went through three major revisions,

00:30:24.280 --> 00:30:39.420
<v Chris Lattner>in, and I think three rounds of review, right? Which is it's really fascinating for such again a simple type. But the trade-offs for such a simple addition are actually quite complicated. And I learned a lot from the discussion and from people

00:30:40.260 --> 00:30:54.190
<v Chris Lattner>talking about their use cases and what they hoped, what they wanted and things like that. Another big aspect of this is that, frankly, the core team didn't want to do this because it felt like a failure of the language, which was kind of interesting.

00:30:54.760 --> 00:31:03.630
<v Chris Lattner>You know, the hope was that with async await or with proper handling, the need for this would go away because it seemed like a bad thing.

00:31:04.160 --> 00:31:19.200
<v Chris Lattner>But the voice of the community was very loud. Thanks a lot for it to your work, and that is what really kind of made it happen. That's one of the reasons it will be a big part of Swift 5. And I think that's really exciting. And I think it's gonna have a huge impact on

00:31:19.710 --> 00:31:23.370
<v Chris Lattner>lots of code out there by standardizing such a common thing that,

00:31:24.690 --> 00:31:30.240
<v Chris Lattner>you know, it doesn't really matter if it's going to go in the future. It's really important right now.

00:31:30.340 --> 00:31:37.380
<v Jon Shier>And I thought it was very interesting to that, during the review cycle, the type changed fundamentally where,

00:31:37.930 --> 00:32:38.105
<v Jon Shier>it was initially both unconstrained on success and failure. But it was, I guess the core team felt very strongly that it was necessary to treated as a real representation of error handling in Swift as what I'd argued before was the manual counterpart to the automatic try catch. And so it came back with revisions that said no, no, no, we need to constrain the error side to error. And in fact, what we're going to do is, we're gonna make an error conform to itself so that you can use it generically over, even APIs returned just plain error, and to me, that was a huge fundamental shift in the error handling. I don't think the implementation of that extension to the language was that complex. But it was one of those things where, you know, I guess if I had been, if I felt I could do that where it was, I had the expertise to go in and say, yeah, I can do this change too because, yeah, I want this. Because I driven result partially because it's the only implementation I needed to do was the addition of the type to the language.

00:32:39.455 --> 00:32:42.075
<v Jon Shier>And thankfully that was

00:32:43.155 --> 00:32:49.565
<v Jon Shier>Yeah, I got a lot of help from members of the community, especially Nate Cook who told me, go here to add a file, go here to do this.

00:32:50.535 --> 00:32:57.805
<v Jon Shier>And so I was able to drive the revisions over and over again, not only as the came back for revision, but also as

00:32:58.475 --> 00:33:15.965
<v Jon Shier>changes to the language itself were made to enable these new versions of results. And so eventually got it nailed down, minimized the API to just the base of what would be necessary that could be built on in the future. And so, yeah, I think it's gonna be a very good part of the language moving forward.

00:33:16.855 --> 00:33:28.045
<v Chris Lattner>It takes an incredible amount of persistence, and it's a lot of work, but that's how we through this winding road, get to a really good result.

00:33:30.000 --> 00:33:32.465
<v Chris Lattner>Yes, we get to a very good result. Literally.

00:33:34.955 --> 00:33:40.125
<v Chris Lattner>Shall we jump in to Kelvin's proposal? Talking about character literals.

00:33:41.455 --> 00:33:53.275
<v Chris Lattner>I think that's another really interesting case of it's been a long and winding road, and this proposal hasn't come up for review yet. And so I'm very curious to know, Kelvin how you got involved, what the proposal is, Maybe you could give us some background on it.

00:33:53.435 --> 00:34:09.722
<v Kelvin Ma>Yeah, So the idea of, like, just ASCII strings has been like talked around in Swift evolution a lot if you like, even in the email days, the mailing list stays and, like, kind of vaguely people thought that there should be some kind of ASCII string type.

00:34:10.392 --> 00:34:31.422
<v Kelvin Ma>And this proposal kind of like turning that on its head. And it was like, what if we just use the existing, like UInt8 ??, kind of like the way that C does for ASCII strings? And then we just change the literal representation so that you could basically pay you back on ?? and use that as an ASCII string type.

00:34:32.272 --> 00:34:43.842
<v Kelvin Ma>And at the same time, we would introduce this new syntax that would kind of take care of this longstanding issue, in Swift where you couldn't really write a character with a capital C

00:34:44.412 --> 00:34:51.182
<v Kelvin Ma>literal, without using "as Character", "as Unicode.Scalar". So you're kind of like dealing with two issues at once.

00:34:51.382 --> 00:34:54.632
<v Chris Lattner>So can you give us a summary of what the bad thing is with current Swift?

00:34:55.252 --> 00:34:57.752
<v Chris Lattner>So what is the problem? What are you looking to solve?

00:34:58.092 --> 00:35:18.622
<v Kelvin Ma>I know, like a lot of people, kind of just default to string and, like Swift tries to be Unicode correct as much as possible. So that's generally a good thing. But also, when you're dealing with stuff that's like explicitly ASCII, string is the wrong model to use. I can go into, like, all the reasons that can cause bugs and stuff,

00:35:19.302 --> 00:35:25.492
<v Kelvin Ma>really like when you want to do, like a byte by byte comparison you don't want to do like Unicode normalization, you know, wanna

00:35:26.012 --> 00:35:27.752
<v Kelvin Ma>be dealing with crafting clusters.

00:35:27.752 --> 00:35:30.692
<v Chris Lattner>Sure, for decoding and HTTP header or something like that.

00:35:30.702 --> 00:35:31.512
<v Kelvin Ma>Yeah, like,

00:35:32.562 --> 00:35:47.822
<v Kelvin Ma>as an example, like some work that I did for the PNG library. So the PNG standard defines like PNG chunks, and this is a binary format. And each header basically has, like a tag, which is a void character ASCII string.

00:35:48.712 --> 00:35:50.662
<v Kelvin Ma>But it's like a very specifically

00:35:51.312 --> 00:35:58.822
<v Kelvin Ma>it's only ever ASCII. And they're really closer and functioned like integer tags, and they really are the strings.

00:35:59.512 --> 00:36:03.222
<v Kelvin Ma>So modeling that with like a string with the capital S type,

00:36:03.812 --> 00:36:06.622
<v Kelvin Ma>it is kind of not really correct.

00:36:07.212 --> 00:36:19.002
<v Kelvin Ma>And if you dig really deep into like the Unicode internals like you can actually find ways to exploit that. There's like vulnerabilities, with that even we can get, like false positives.

00:36:19.042 --> 00:36:27.582
<v Chris Lattner>This is where the C language is really simple, right? If you have double quotes around something, you have a string. If you have single quotes around something, you have C's notion of a character.

00:36:27.652 --> 00:36:38.000
<v Kelvin Ma>Yeah, now you're getting into the whole, like differentiating characters from strings and the syntactical difficulties with that which have been long standing in the language.

00:36:38.000 --> 00:36:46.852
<v Chris Lattner>Well, C's kind of messy here, if you dig into the way C works. Because C has Unicode and wide character strings and

00:36:47.572 --> 00:36:52.912
<v Chris Lattner>C++ does. And they are all kind of weird and broken and messed up in various ways.

00:36:52.922 --> 00:37:08.322
<v Kelvin Ma>Really, like no language I think has really good solution to the Unicode problem, but like adding these character in the ASCII literal to Swift kind of gives Swift developers the variety towards

00:37:08.982 --> 00:37:17.262
<v Kelvin Ma>needed to solve various kinds of stringing problems without having to resort to string, which might not be appropriate in all cases.

00:37:17.422 --> 00:37:37.922
<v Chris Lattner>Sure, and so this is part of the general thrust in Swift to improve string and the ergonomics of working with the string type and with string kinds of problems. And string itself, as you said, is really designed to be Unicode correct by default. And there's a corresponding capital C character type,

00:37:39.172 --> 00:37:39.932
<v Chris Lattner>holds one

00:37:41.362 --> 00:38:08.992
<v Chris Lattner>logical human character, and the controversial and exciting and, I think correct thing that Swift does is not just a byte in that character. It can actually store a full Unicode. What's called a graphene cluster, which has lots of extended graphene cluster, which has the lots of Unicode code points potentially, and all the hats and the weird things that Unicode can do, are all stored together in one character.

00:38:09.856 --> 00:38:16.236
<v Chris Lattner>Which is good. I think that it's good that string by default models and can be used for a human level

00:38:16.876 --> 00:38:28.586
<v Chris Lattner>string representational problems. But that becomes a problem if you get back to your use case of, you actually have a weird protocol. You actually have a binary format, and you don't wanna type in the ASCII number for

00:38:29.306 --> 00:38:28.800
<v Chris Lattner>character to get it as a byte.

00:38:28.875 --> 00:38:36.246
<v Kelvin Ma>Yeah, I feel like separating the string domain and the machine string domain,

00:38:36.716 --> 00:38:54.636
<v Kelvin Ma>It's probably like ?? better if Swift, especially since basically like every month you get someone coming onto, like, Swift evolution and asking basically, why we don't have an issue subscripting into string. And usually like the motivation for that is to try and get like,

00:38:55.276 --> 00:39:12.356
<v Kelvin Ma>a slice of data from, like, a certain offset in a machine encoded string, like a date string or like a server log. And that would be, like so much better model just as plain ASCII with UInt8 characters instead of like capital C characters.

00:39:12.556 --> 00:39:17.226
<v Chris Lattner>Right, but so can you ??, why the Swift string cannot be subscripted with integers.

00:39:17.316 --> 00:39:26.076
<v Kelvin Ma>Well, that's cause strings characters aren't fixed width, so you can't calculate in constant time these offsets.

00:39:26.076 --> 00:39:30.786
<v Chris Lattner>So if you have a huge string and you say give me index 57

00:39:30.876 --> 00:39:34.626
<v Kelvin Ma>You have to walk it over. It's kind of like a link list almost.

00:39:34.846 --> 00:39:41.586
<v Chris Lattner>And so what would end up happening is people would end up writing a for loop says, for i equals zero to string.length,

00:39:42.176 --> 00:39:47.296
<v Chris Lattner>give me string[i] and now you get an squared algorithms and things like that.

00:39:47.306 --> 00:40:00.276
<v Kelvin Ma>Yeah, well, what a lot people do is they just trying, like, translate the python code as directly as possible so they would take, like, their integer subscript. And we're just, like replace it with index.offset by blablabla,

00:40:01.156 --> 00:40:04.586
<v Kelvin Ma>without really realizing the performance implications of that.

00:40:05.576 --> 00:40:12.826
<v Chris Lattner>Right, so you're now taking the controversial approach of saying maybe characters should look like characters in C.

00:40:13.696 --> 00:40:26.046
<v Chris Lattner>Let's use single quotes for characters, right? And I should say, this is your proposal, this also has John Holdsworth as a co-author as well, and somehow I got listed as co-author. But I don't think that I have done much of the work.

00:40:26.166 --> 00:40:31.600
<v Kelvin Ma>I mean, you were like the original proposal...it's a community effort.

00:40:31.650 --> 00:40:53.726
<v Chris Lattner>Yes, it's a community effort. So you're taking the controversial approach of saying let's use single quotes to represent characters. But that also leads to other challenges because some people want one byte characters. Some people want two byte characters. Some people want four graphing cluster crazy Unicode characters, and so you talk about how that works and what that means.

00:40:53.866 --> 00:41:08.206
<v Kelvin Ma>Well, the great thing about Swift is that we're pretty good at separating syntax, literal syntax from types themselves. So we're not really like, okay like we have one syntax that translates to a ?? one, one kind of builtin type.

00:41:08.776 --> 00:41:30.366
<v Kelvin Ma>Like currently with the double quoted literals like that could represent a static string, the string "Unicode.Scalar" character. So with the single quote literals will kind of narrowing that space and kind of separating off the double quote literal is what we're still like able to satisfy multiple use cases.

00:41:30.896 --> 00:41:40.676
<v Kelvin Ma>So in cases where it can be inferred to be a Unicode scaler character, it can be basically a multi byte character, a multi code point character.

00:41:41.406 --> 00:41:49.606
<v Kelvin Ma>And in context with infer to be an integer, then we can restrict it to ASCII restricted to a single byte character.

00:41:50.396 --> 00:41:52.700
<v Kelvin Ma>And kind of you get the best of both worlds that way. 

00:41:52.750 --> 00:41:58.796
<v Chris Lattner>Yes it's kind of a nice, it should be safe by default. So if you say, let x equals quote

00:41:59.976 --> 00:42:01.006
<v Chris Lattner>cow or,

00:42:01.536 --> 00:42:06.746
<v Chris Lattner>emoji pile of poo, you get the correct Unicode

00:42:07.566 --> 00:42:16.026
<v Chris Lattner>character concept, but if you pass 'x' to a C API taking a char,

00:42:16.616 --> 00:42:18.736
<v Chris Lattner>then it just does the right thing.

00:42:19.216 --> 00:42:28.716
<v Kelvin Ma>Yeah, I feel like we're leaning pretty heavily on the type system to get it to do what it should do, which is a good thing. I think that's a heavy precedented in Swift.

00:42:29.546 --> 00:42:31.106
<v Chris Lattner>So now what happens if you pass

00:42:31.876 --> 00:42:34.416
<v Chris Lattner>some Unicode dog

00:42:35.776 --> 00:42:39.166
<v Chris Lattner>emoji think into C API that expects the char

00:42:39.856 --> 00:42:47.726
<v Kelvin Ma>That would be a compile-time error, which is another like major selling point of the proposal, cause kind of the land of

00:42:48.516 --> 00:43:03.426
<v Kelvin Ma>the land of characters previously was kind of very, very runtime error based. So you really had no way of checking that what you were writing wasn't ASCII scaler for example. You would have to, like, one time assert that or

00:43:04.066 --> 00:43:07.666
<v Kelvin Ma>type that as like a little numerical value,

00:43:08.096 --> 00:43:15.676
<v Chris Lattner>Yeah. So I love the proposal because it leads to more clear code that's more self evident, better catching of errors,

00:43:16.766 --> 00:43:18.386
<v Chris Lattner>covers more use cases,

00:43:19.056 --> 00:43:22.456
<v Chris Lattner>reaches down into the systems level stuff too, which is really great.

00:43:22.606 --> 00:43:33.346
<v Kelvin Ma>Yeah. What I like the unwritten kind of design goals of Swift is like better static checking, better like static verification. So I think this is like an important step towards that.

00:43:34.106 --> 00:43:37.276
<v Kelvin Ma>Improving compile-time safety.

00:43:37.496 --> 00:43:53.826
<v Chris Lattner>Yeah, the way I look at is that Swift is not trying to minimize the amount of syntax right? It's not about get the least possible punctuation or the least possible characters into your code. It's about round tripping and shortening the time it takes to

00:43:54.416 --> 00:44:21.259
<v Chris Lattner>achieve something that is correct, right? And so if you have super dynamically type languages or super dynamically type APIs, then it's easy to pound out code maybe, but then you have to spent a lot of time in the debugger, to get it to be correct, right? And so you're trading off. Okay, well, static checking can sometimes be slower to pound out code because you have to write types and you have to deal with the type checker and things like that. But you're moving development time from

00:43:55.880 --> 00:43:57.000
<v Kelvin Ma>Yeah, absolutely.

00:44:21.839 --> 00:44:23.669
<v Chris Lattner>debug time into

00:44:24.769 --> 00:44:26.469
<v Chris Lattner>that authorship time.

00:44:26.500 --> 00:44:31.959
<v Kelvin Ma>Yeah. Honesly, like debugging is quite a bit harder than typing. So,

00:44:32.349 --> 00:44:32.669
<v Chris Lattner>Yeah,

00:44:33.749 --> 00:44:38.239
<v Chris Lattner>yeah, well, and it's also fascinating when you cross it with the

00:44:38.779 --> 00:44:49.259
<v Chris Lattner>aspect of code where code gets evolved and maintained by lots of different people. And therefore there's this art of how much deeper in the code such that you're capturing the essential,

00:44:50.049 --> 00:44:59.709
<v Chris Lattner>the essential maintainable understandable abstractions and other things like that, that you need for the code, your writing, but without filling it full of boiler plate.

00:45:00.289 --> 00:45:12.359
<v Chris Lattner>Well, I'm really excited to see what happens. I expect this will come up for review in a few weeks. I think Swift 5 is winding down, and so this will be an exciting new thing. Hopefully, it'll get in Swift 5.1. We'll see.

00:45:12.949 --> 00:45:17.969
<v Chris Lattner>Jon, you have any other things you'd like to talk about with character literals or with results?

00:45:18.549 --> 00:45:37.589
<v Jon Shier>No. I mean, I've been following the character literal proposal from the outside, mostly looking in to see where it goes, because I think that is one of the big parts of Swift that I would like to see improved or one of, I guess, is the ability to, like Kelvin said to be able to

00:45:38.249 --> 00:45:43.469
<v Jon Shier>use Swift more natively to parse some of those low level representations that we sometimes have to use.

00:45:44.549 --> 00:46:18.229
<v Jon Shier>You know, byte streams coming over the network and things like that would be very useful to be, you know, more natively representative the language. And I view the work that's going on in that proposal. Similar to what we got out of the string interpolation proposal, which is just a whole new area of like a protocol that represents something that was fundamental to Swift and then took it and open it up into something that's gonna create so much more flexibility for the language, and allow us to use it in so many more unexpected ways. And I think that the character literal proposal, with the extra protocols that it's added has sort of,

00:46:18.769 --> 00:46:36.919
<v Jon Shier>and the other representations that can go into it, have added a similar level of extra flexibility that I think will open up a lot of different areas of development that just weren't there before. And it's something that I hope to also see expanded in, you know just regular string parsing and human strings

00:46:36.919 --> 00:46:37.679
<v Chris Lattner>and things like that.

00:46:38.379 --> 00:46:47.679
<v Chris Lattner>Right, that's my favorite kind of proposal also is something that takes a hard coded aspect of language and then makes a generic and open. And,

00:46:48.719 --> 00:46:54.229
<v Chris Lattner>for example, there's a lot of syntactic sugar pieces that are hard coded optional right now, and

00:46:54.769 --> 00:47:02.969
<v Chris Lattner>opening those up, for example, optional chaining, and so opening those up to be library extensible would allow result to participate with some of that, for example.

00:47:02.979 --> 00:47:14.379
<v Jon Shier>Yeah, and I think that was one of the especially in the early discussions about result was, well, it's okay to have this type, but where's everything else that goes around it? And I was like, well,

00:47:14.929 --> 00:47:49.679
<v Jon Shier>let's just get the type in their first, and then we can see how it could fit side by side. Because I think, it's one of those things where what we had talked about earlier with the evolution process, where it's always interesting to see how code is used, and see what things are possible, what things people want to do with it. So I think the, yeah, that will be the next step, trying to find good ways to integrate result more automatically. I imagine that when some sort of async await or whatever form the asynchronous work and Swift takes, that result will be some part of that around the error handling. And then whether we have,

00:47:50.719 --> 00:47:58.039
<v Jon Shier>you know, like a future type or something that manually wraps a synchronous work like result wraps error throwing work,

00:47:58.639 --> 00:48:19.356
<v Jon Shier>something like that. There's a lot of room for symmetry there, and then also, once we see how, now that it's part of the language, how we see that now that's opened up to more users, how we see that the type is used by by more than just those people who knew of a result type of wrote it themselves. And see how it's used and see how we can get it into

00:48:19.906 --> 00:48:28.626
<v Jon Shier>yeah, things like chaining to see how that would work, things like some sort of automatic mapping from Objective-C API.

00:48:29.166 --> 00:48:33.186
<v Jon Shier>All of those things, I think can come around and build on top of the base type. But

00:48:34.046 --> 00:48:44.456
<v Jon Shier>yeah, it was one of those things, right? Didn't want to tackle all of the design decisions around all of the integration of this type into the language at the same time, I just wanted to focus on the core type itself.

00:48:44.676 --> 00:49:19.746
<v Chris Lattner>Yeah, that makes absolute sense, and I think that you're also highlighting an aspect of Swift evolution process, which is kind of this step by step incremental piece, where smaller more focused proposals end up being more successful than uber proposals that are trying to solve everything all at once. And that makes the process move a little bit slower, but I think it's good because, as you said, once the type is in there, we can see how people use it. We can see what the effect is on the community and the global code everywhere that has been doing result like things, and it makes it easier to evaluate that next step.

00:49:20.146 --> 00:49:22.766
<v Jon Shier>Yeah, there's always two sides of the coin there,

00:49:23.376 --> 00:49:30.486
<v Jon Shier>and there's always small proposals that come in and add something to the language and then another small proposal that comes in it as another thing to the language.

00:49:31.026 --> 00:49:41.706
<v Jon Shier>Unfortunately, though, I don't know if evolution is really designed around, like holistic reevaluation of things like that, something like the,

00:49:42.436 --> 00:49:49.186
<v Jon Shier>you know we now have, we have regular string with literals with multiline string literals, and we have raw string literals, all of which

00:49:49.966 --> 00:50:09.516
<v Jon Shier>look different and they work a little bit differently. It's one of those things. All those features came in separately, and I have to wonder sometimes if they had all coming at the same time, that if maybe they would look more similar and maybe not be quite as separate. But you know we'll see how that further evolves later on in the language as well.

00:50:10.816 --> 00:50:18.469
<v Kelvin Ma>like the manifestos is kind of like, one like guiding kind of like roadmap or allow these features. But

00:50:19.059 --> 00:50:28.719
<v Kelvin Ma>again, like, I don't really know where they all come from. They kind of just there. And they're kind of more opaque to the community than other aspects of Swift evolutions.

00:50:29.079 --> 00:50:33.419
<v Chris Lattner>Yeah, the manifestos are, the problem the manifestos try to solve is,

00:50:34.059 --> 00:50:41.889
<v Chris Lattner>if everything becomes an incremental small step proposal, then how do you know you're going to end up in a good place?

00:50:42.699 --> 00:50:45.009
<v Chris Lattner>You know how are these small steps

00:50:45.659 --> 00:50:56.809
<v Chris Lattner>combining together to lead to a good, well thought out, consistent design? So one example of that is the generics manifesto, which is saying, here's the

00:50:57.359 --> 00:51:14.669
<v Chris Lattner>the many year journey that generics improvement features could end up looking like, along with a fairly informed assessment about what actually doesn't make sense to ever add, providing kinda none goals. What makes sense is really, really obvious and pieces that just need more discussion and debate.

00:51:15.209 --> 00:51:32.229
<v Chris Lattner>But by having that kind of framework, you establish common terminology. You give the community way of thinking about things, and you have in some cases the ability to say like, this is never going to happen, right? This is actually be a bad thing for X, Y or Z reason, and that also helps with

00:51:32.739 --> 00:51:35.169
<v Chris Lattner>channeling the energy in the community, that way.

00:51:35.959 --> 00:51:39.869
<v Chris Lattner>There's another aspect that you mentioned here, Jon, though, which is,

00:51:40.559 --> 00:51:47.599
<v Chris Lattner>in the absence of manifesto, for example, how do you know that the piece is composed properly, like, how do you integrate across

00:51:48.419 --> 00:51:53.749
<v Chris Lattner>anyone proposal and think about where this language go. And this is really, I think, the

00:51:54.289 --> 00:52:15.798
<v Chris Lattner>the hidden side of the Swift core team. It's something that it's not hidden from, like intentionally, like ??. I think it's just something people don't generally think about. A lot of the role of the core team is to look at these proposals and think beyond the individual proposal itself. And so one of the things the core team tries to do is

00:52:17.038 --> 00:52:22.538
<v Chris Lattner>when the proposal is accepted. If it's not obvious, right, if there's controversy which frequently there are,

00:52:23.148 --> 00:52:32.958
<v Chris Lattner>write per really detailed rationale and the rationales if you go through the proposals can sometimes be really interesting because many of these proposals end up being,

00:52:33.728 --> 00:52:40.768
<v Chris Lattner>what precedent do we want to set. What case law gets established for how to handle various situations. What kinds,

00:52:41.438 --> 00:52:46.568
<v Chris Lattner>if we accept this proposal, is this a slippery slope to accepting a whole bunch of other proposals that are like it?

00:52:47.128 --> 00:52:54.388
<v Chris Lattner>And I think this could end up being very frustrating the community, because in the cases result for example, one of the discussions was

00:52:55.078 --> 00:52:58.928
<v Chris Lattner>the type is so simple, do we want tons of simple things in the language?

00:53:00.028 --> 00:53:05.938
<v Chris Lattner>And the same to library? That's a divisive kind of position with frozen ?? sides.

00:53:06.938 --> 00:54:08.888
<v Jon Shier>Right, I think that was some of the biggest work that was done by the core team and the revisions to the result proposal was, basically additions to the proposal, saying why they didn't want certain things. You know, those parts of the proposal weren't parts that I wrote. Those were added as it went through revisions, things like what we don't want it. We do want it to be constrained on the error side, because we do want it to represent how we want error handling to work in Swift. We don't want all of these additional functions on it, because you know, maybe we haven't settled on naming for, you know, the type of operation that is like a throwing closure that's captured in type of, inside of a result. Or, you know, what's the name of something that you know turns a result into a throwing function again. And so discussions on how that naming came and went through the proposal process, which I would then take and then re implement using the new naming conventions and things like that. So that was an interesting part that additional explanation that was added to the proposal as it went through the process itself.

00:54:09.188 --> 00:54:11.598
<v Chris Lattner>And this is one of the great things about Swift evolution.

00:54:12.558 --> 00:54:34.566
<v Chris Lattner>GitHub repo, is that you can go through and you can see a lot of that. A lot of those rationales, a lot of the proposals, the revisions of the proposal, and so there's a lot of archaeology in there, and you can kind of see it very detailed level how a decision got made, as well as the of course, hundreds of emails and the threats that end up debating the individual points.

00:54:34.736 --> 00:54:48.826
<v Jon Shier>Yeah, added them up in between the two discussion or two main discussion threads, one of which was partially an email thread. And then also the reviews. There were something like 530 posts about result discussing it in Swift evolution. So,

00:54:48.996 --> 00:55:25.200
<v Chris Lattner>that's quite a few. And results are also interesting. There's this notion of bike shedding. If you have a nuclear reactor, all the bureaucrats want talk about the color to paint the bike shed out back. They don't want to talk about the design of the reactor themselves. And the analogy and Swift evolution is, if it's something that is easily approachable and everybody understands, something like result, then you'll get a lot of comments, a lot of feedbacks, a lot of opinions. If it's, we're gonna change some crazy internal implantation detail of the type checker to enable blablabla. Then you get a lot less discussion.

00:55:25.250 --> 00:55:49.376
<v Jon Shier>Right, that was one of the reasons why when I approached it the second time, I cut up a lot of the convenience API that was on the Alamofire result type, you know, additional things that can help with chaining results and stuff like that. And then those were further cut by the core team as it went through revision as well. Just get down to the absolute minimum set of functions that they wanted with the type fundamentally,

00:55:50.176 --> 00:56:00.156
<v Jon Shier>to get to where we are now, so that now we can use it in the language and build it back up to add further convenience to see what users may want out of it.

00:56:01.126 --> 00:56:06.696
<v Chris Lattner>And the notion of removing those methods was driven for two reasons, one of which was,

00:56:07.346 --> 00:56:08.646
<v Chris Lattner>you can always add things later.

00:56:09.376 --> 00:56:14.890
<v Chris Lattner>Adding a method to type in Swift is really easy, and a future proposal can do that. But once you add something you can't take it away.

00:56:15.460 --> 00:56:22.230
<v Chris Lattner>Another aspect of that was really kind of trying to focus the core of the proposal and get a certain set of,

00:56:22.780 --> 00:56:33.350
<v Chris Lattner>how are the enum cases named? What is the shape and type in the core behavior of this thing? Which are kind of separable from the user convenience APIs.

00:56:34.200 --> 00:56:39.890
<v Kelvin Ma>Yeah, that the character literal proposal has like a similar thing. At first, we were proposed

00:56:40.490 --> 00:56:51.890
<v Kelvin Ma>defining the multiplication operator in the addition operator on character, so that you could do like "a + a" and you get "aa" instead of it getting inferred like an integer.

00:56:52.680 --> 00:57:01.710
<v Kelvin Ma>But like that got taken out because that's kind of just like inviting argument about what should character multiplication being like, you know,

00:57:02.380 --> 00:57:05.510
<v Kelvin Ma>do we want to emulate this like python behavior like

00:57:05.520 --> 00:57:09.790
<v Chris Lattner>Yeah, "x * 4" gives you "xxxx".

00:57:10.380 --> 00:57:20.190
<v Chris Lattner>Well, in all those things can be discussed, and they could be future proposals. But keeping the core, let's fix the basic syntax for characters in the language is inseparable

00:57:20.760 --> 00:57:23.590
<v Chris Lattner>itself, really important, starting point for that.

00:57:24.750 --> 00:57:35.130
<v Chris Lattner>So do either of you have ideas on how Swift evolution could be improved? I mean, it's obviously perfect, right? So what things frustrate you? What do you think could be improved?

00:57:35.980 --> 00:57:54.610
<v Kelvin Ma>I mean, I think it would be better if we have, like, a better way like keep proposals on track and moving forward. Cause I feel like it's way too easy to do a little process right now, like there's not really like any factual like keep things moving along like, yeah,

00:57:52.750 --> 00:57:54.667
<v Chris Lattner>Yeah. I share your concern.

00:57:55.220 --> 00:58:01.390
<v Kelvin Ma>Yeah like people like bike shedding, like evolving stuff. And then, just like eventually everyone gets tired and, like, kind of forgets about it.

00:58:02.625 --> 00:58:04.870
<v Chris Lattner>Well, one of the challenges there's that,

00:58:05.380 --> 00:58:15.610
<v Chris Lattner>you know, sometimes the people who speak the most can kind of overwhelmed the conversation. And this doesn't happen super often. But there occasionally people that

00:58:16.400 --> 00:58:32.210
<v Chris Lattner>are really passionate about it and are not super, not about your proposal specifically, but about proposals in general, they're very passion about some proposal, and they're not very aligned with the rest of the community. And so they can consume a lot of energy and a lot of, take a lot of

00:58:32.930 --> 00:58:36.230
<v Chris Lattner>out of the rest of the conversation, which could be distracting.

00:58:36.400 --> 00:58:47.910
<v Kelvin Ma>Yeah, I think the character literal proposal is nearing on, like, 250 posts. But if you look at like the actual text of, like definition, it hasn't really changed that much.

00:58:48.590 --> 00:58:51.540
<v Kelvin Ma>Like, I think the only major revision was that we

00:58:52.130 --> 00:58:57.260
<v Kelvin Ma>kind of restricted the code point ?? ASCII for the other integer inferences.

00:58:57.930 --> 00:59:06.340
<v Kelvin Ma>So like other than it was kind of like people bike shedding over whether or not this syntax was right, whether or not yeah.

00:59:06.000 --> 00:59:09.960
<v Chris Lattner>Well in those bike sheds could be really frustrating. But

00:59:11.040 --> 00:59:31.810
<v Chris Lattner>so there have been several standard library proposals where the proposal is, just add this one method, right? And the entire discussions around, well, what is the nature of this method? How do we name it? And it's just about the name. Everybody agrees about the semantics. But again, while that's super frustrating, I'm really glad that the community does that,

00:59:32.840 --> 00:59:37.110
<v Chris Lattner>because it leads to a more consistent result. And many of those discussions end up

00:59:37.650 --> 00:59:53.570
<v Chris Lattner>providing that kind of case law. Here's the pattern. Here is the principle that underlies why this choice was made. And the idea is that gets generalizing applied across the language going forward. Which means that now there's an answer to a much broader question than the one,

00:59:54.300 --> 00:59:58.150
<v Chris Lattner>the one proposal and Jon's result proposal for example,

00:59:58.700 --> 01:00:00.910
<v Chris Lattner>there's a fairly interesting discussion about

01:00:01.820 --> 01:00:07.240
<v Chris Lattner>what the enum case names named, right? And do you want to talk about that, Jon?

01:00:07.700 --> 01:00:39.500
<v Jon Shier>Yeah, there was a lot of attempt to apply the names of the result cases to principles that people saw in Swift. So the principle of Swift says this so therefore the case name should be value and error, or the principles of Swift say this so therefore the generic types should be wrapped. And, you know, there are something like that. And so there were a lot of back and forth on those different aspects, and it was eventually trying to settle down on,

01:00:40.220 --> 01:01:44.540
<v Jon Shier>what could have the best semantic impact when people use it in their code? What is the best representation? And so I really wanted to avoid like Rust result type, which I believe the cases are okay an era. And so I really wanted something that could be semantically useful, was readable and was also meaningful to people reading it sort of as plain English. And so I was a big proponent of success and failure. And that actually went back and forth inside of the revisions. The first revision to the proposal change those case names to value and error. And so once it became clear that was going to be accepted, though I think the community came back and sort of said, you know, the voices of the community that had agreed with the original spelling came back out and said, no, no, no, we like to this original spelling and so we're able to convince the core team to go back to the success and failure. Well, you know, changing some of the generic types as well. And so went really back and forth on that to try and get to a

01:01:45.320 --> 01:01:52.130
<v Jon Shier>get to a principal point of, you know, semantic meaning for the case names and the generic type names.

01:01:53.020 --> 01:02:20.750
<v Chris Lattner>In an aspect of that is that the core team is made up of humans, and humans have their own opinions. They are imperfect, right? And so I think that is a really important aspect that, you know the people working and serving on the core team and having to deal with this and having the weight of responsibility to make good decisions on their own shoulders. Is a big piece of it. But it's also critical that the community is involved in that. And,

01:02:21.340 --> 01:02:27.530
<v Chris Lattner>It's a long and challenging process, but I think it's overall pretty good.

01:02:28.250 --> 01:02:32.520
<v Chris Lattner>But if there's other ways to improve it, I'm sure that many people would love suggestions.

01:02:32.680 --> 01:02:45.250
<v Jon Shier>Well, I mean, it's raising the bar with the implementation, really, at least for me, as somebody who's not a C++ developer who doesn't know anything about compiler design, and who's like language principles

01:02:45.810 --> 01:02:53.390
<v Jon Shier>like principles of computer languages was really one class at college and then what I've basically read while on the Swift forums.

01:02:54.150 --> 01:03:10.260
<v Jon Shier>It can be difficult to say, I think would be really good to have this language feature, I could even design the syntax of it. But I have no idea how to implement any of this. And so trying to connect with people to say, would you like to implement this for me? Would you like to implement this for me?

01:03:10.940 --> 01:03:37.450
<v Jon Shier>Or trying to spend the time to build the expertise myself, was one of the reasons why I focused on resulting in that I could stay strictly within Swift itself. You know one of the great things about Swift is that most of the big types of the language and a lot of the functionality is written in Swift itself. So I could go in and you know feel perfectly comfortable since I write Swift in my day job and my night job, I guess, to go and,

01:03:38.490 --> 01:03:44.040
<v Jon Shier>and implement something in the Swift standard library just in Swift itself. And I didn't have to touch any of the other parts.

01:03:44.670 --> 01:03:53.640
<v Kelvin Ma>Well, that's part of the rationale for like, the whole we implement the Swift compiler, and Swift like idea that was, like, floated around a while back.

01:03:53.770 --> 01:03:55.540
<v Chris Lattner>Yeah, if somebody just sent upon request.

01:03:58.070 --> 01:04:02.150
<v Chris Lattner>And all seriousness, I think many, many people would love to see that.

01:04:02.840 --> 01:04:14.790
<v Chris Lattner>The question is, exactly how do you stage, how do you build that? How do you prioritize that things like that. It would be great to have somebody who's passionate about that. Come on the show sometime and we could talk about that.

01:04:16.360 --> 01:04:18.700
<v Chris Lattner>So I think that it's about time to wrap things up.

01:04:19.420 --> 01:04:27.300
<v Chris Lattner>As one of our producer, our esteemed producer Garric, is on the show and maybe he wants to jump in and talk with us, too.

01:04:27.520 --> 01:04:41.470
<v Garric Nahapetian>Hello, yes I am. I feel kind of like bad, almost like we've been lying to our listeners this whole time because I've been listening to this episode the entire time as it's been recorded. But yeah, I am here.

01:04:41.480 --> 01:04:45.890
<v Chris Lattner>That's because you're the expert. You're the one that's making everything happen and possible here.

01:04:45.980 --> 01:04:59.870
<v Garric Nahapetian>Oh, man. But I have to say, this episode has been so good. I'm very impressed by all of you. So yeah, I do have some follow up. The first is the intro song issue. So Gorka Ercilla, I believe. He

01:05:00.630 --> 01:05:11.110
<v Garric Nahapetian>posted a while ago in issue #23 about creating a podcast song, and then in a follow up, PR #34.

01:05:11.640 --> 01:06:12.670
<v Garric Nahapetian>Sorry #35. He actually introduces a podcast song. And then in PR #34 Marcus Rossel, he also introduced a podcast song. That's really cool. We have two people who want to contributed a song to the podcast. We have PRs open, so please go review those PRs, listen to the music, and then I think they both have really good suggestions where maybe we can have a catalog of accepted songs that future producers or editors can choose from. And then Gorka has a suggestion, I believe. Which is maybe each season has its own intro outro songs. You can kind of distinguish the show based on the song for that particular season. So thank you to Gorka and Marcus for those PRs. Go check out those PRs, #35 and #34. Listen to the music. Let us know what you think. The next is Julian Kahnert PR #36.

01:06:13.400 --> 01:06:30.590
<v Garric Nahapetian>He adds issue templates so this is a PR that's open to add issue templates to the repo. So, for example, if I want to post a topic, I don't want a post in issue. You could use this template as a way to post that issue. So if you want to

01:06:31.300 --> 01:07:25.080
<v Garric Nahapetian>suggest a speaker, we might have a format like a template for that particular issue. And so it is a PR that would add three or four looks like four markdown files. And so if I want to contribute, I want to suggest the speaker I could find the speaker suggestion template, issue template, and I could fill it out and post it. So that's issue #36 Julian Kahnert. Thank you so much for opening that pull request, Please everyone take a look at that and let us know your thoughts. And lastly, I just wanted to thank Bas Thomas for last episode, episode 2. And as a follow up, he opened issue #28 where he talks about episode collaboration. And essentially, Bas is saying in suggesting what if we allow the contributors to the repo to the podcast to have discussions, GitHub discussions

01:07:26.380 --> 01:07:45.240
<v Garric Nahapetian>about the episode that they're producing. So this is a new feature. I think I haven't heard of it on GitHub where you can form small groups of contributors on a repo. And then they can have discussions almost like a discourse or something. So it's like a private discussion outside of the issue and pull request

01:07:46.180 --> 01:07:46.730
<v Garric Nahapetian>space.

01:07:46.860 --> 01:08:06.510
<v Chris Lattner>That sounds really fantastic. I mean, that's one of the most challenging aspects of organizing the episodes, is getting the people together and talking about the exact content, and we often make it up right before the show. But, it would be great to get more community engagement, get that more transparent and open.

01:08:06.660 --> 01:08:07.020
<v Garric Nahapetian>Yeah,

01:08:07.630 --> 01:08:12.820
<v Garric Nahapetian>so that's it for follow up this week, but, yeah thanks for let me listen in. And it's been really fun producing this episode.

01:08:13.350 --> 01:08:27.653
<v Chris Lattner>Well thank you for producing the episode and I also want to thank Jon and Kelvin for joining us to talk about Swift devolution and talk about both the process, but use their proposals as a lens to see it through. And I really appreciate you both sharing your experience and your insights.

01:08:27.783 --> 01:08:30.113
<v Jon Shier>Well, thank you, Chris. It's been great to be here. And

01:08:31.013 --> 01:08:35.923
<v Jon Shier>it's been very interesting to hear your insights into the history of the evolution process and how it works right now.

01:08:36.013 --> 01:08:46.363
<v Kelvin Ma>Yeah. Thanks for having me, Chris.

01:08:37.875 --> 01:08:39.774
<v Chris Lattner>Yeah, so where can people find you Kelvin?

01:08:40.000 --> 01:08:46.500
<v Kelvin Ma>Very active on the Swift forums. And, I also have a GitHub at Kelvin13

01:08:46.913 --> 01:08:56.323
<v Kelvin Ma>which is my username there so you can come if you have, like, anything to talk about. Like a specific project like publish, You can feel free, like opening issue on that.

01:08:57.000 --> 01:09:07.023
<v Chris Lattner>Sounds great. So I also have to ask you, so since we're almost done, why is your handle on the Swift forums Taylor Swift. How'd that come to be?

01:09:07.273 --> 01:09:28.743
<v Kelvin Ma>I mean, I come from a community of fan girls for, like, Taylor Swift, the actual like singer and how, like the convention, would like choosing user names like Twitter Tumblers, like try and get the various one possible. Usually is like the celebrity handle itself. It's like on Tumblr someone used to have quality class, until I come early actually expanded onto that platform.

01:09:29.313 --> 01:09:32.653
<v Kelvin Ma>So when I like, but basically it was available, so I took it.

01:09:33.213 --> 01:09:38.023
<v Chris Lattner>I'm sure Taylor will be grumpy someday when she comes in to try to add a new language feature to the language.

01:09:39.113 --> 01:09:40.433
<v Chris Lattner>Jon where can people find you?

01:09:40.883 --> 01:09:43.083
<v Jon Shier>Most of the time people can find me on GitHub.

01:09:43.663 --> 01:09:59.223
<v Jon Shier>@jshier on there. I spent most of my time in the Alamofire project. When I'm not working here, I'm also on the Swift forums a lot. And we've tried to expand our Alamofire support to the Swift forums and the associated libraries or the community library section, whatever that's called.

01:09:59.813 --> 01:10:02.233
<v Jon Shier>So people have questions about that, they can

01:10:03.933 --> 01:10:08.873
<v Jon Shier>post on the forums itself from around forums. And if you want to reach out through the forums too.

01:10:10.693 --> 01:10:12.203
<v Jon Shier>I'm technically on Twitter but I never posted anything.

01:10:14.933 --> 01:10:16.913
<v Chris Lattner>Fantastic. Well thank you both. And thank you to everyone who listens.
